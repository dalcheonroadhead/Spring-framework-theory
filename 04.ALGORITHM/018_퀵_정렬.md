# 1. Quick 정렬은 무엇인가? 

`Pivot(중추)`가 되는 값을 하나 선정해서 그 값보다 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 모은다. 이제 나눠진 두 그룹 내에서 다시 Pivot을 선정하고 이 과정을 반복한다. 값을 **더 이상 쪼갤 수 없을 때**까지 반복하면 모든 값이 정렬되어 있다.

# 2. 원리

병합정렬과 마찬가지로 분할 정복을 활용하는 또 다른 예시이다. 병합 정렬에서는 **선 분할 후 정복** 이었다면, quick 정렬은 **선 정복, 후 분할** 형식이라 생각하면 되겠다.

정복에는 **마주보는 투 포인터**가 활용된다. 어떻게 쓰이는지는 밑의 예시에서 설명하겠다.

- (1) Pivot 정하기 (정하는 방식은 때에 맞게 자유)
- (2) Pivot보다 큰 값은 오른쪽으로 몰기, 작거나 같은 값은 왼쪽으로 몰기 (정복 by `투 포인터`)
- (3) 나눠진 두 그룹에 대해서 재귀를 활용해 (1),(2)번 다시 진행 - 더 이상 재귀할 수 없을 때까지 (분할 by `재귀`)

.

(2)번을 좀 더 세세하게 설명하면,

`L(왼쪽)`포인터, `R(오른쪽)` 포인터가 있을 때, 

- `L` 포인터는 pivot보다 작거나 같은 값을 만나면 한 칸 전진, 큰 값을 만난다면 그 위치에서 기다림.
- `R`  포인터는 pivot보다 큰 값을 만나면 한 칸 전진, 작거나 같은 값을 만난다면 그 위치에서 기다림.
- 두 포인터 모두 `기다림` 상태라면 둘의 value를 자리 교체
- 이 행위를 **두 포인터가 엇갈릴 때까지 반복**

# 3. 예시

![image-20241231150936179](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231150936179.png)

pivot 값을 index = 4인 `6`으로 정해보자. 중앙의 값으로 정해서 따로 값을 중앙에 위치시킬 필요는 없다.

![image-20241231151033574](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231151033574.png)

이제 마주보는 투 포인터를 설정한다.

![image-20241231151156712](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231151156712.png)

`index = 0`의 값은 1로 6보다 작다. 따라서 왼쪽 포인터는 한 칸 전진한다. 반면 오른쪽 포인터가 가르키는 `index = 9`의 값은 3으로 6보다 작다. 이때 오른쪽 포인터는 **Switching 할 값을 만날 때까지 대기**해야한다.

 ![image-20241231151324732](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231151324732.png)

왼쪽 포인터가 가르키는 값이 7로 6보다 크다. 따라서 오른쪽 포인터의 3과 값을 `switching` 해준다. 

![image-20241231152251607](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231152251607.png)

이런 식으로 **두 포인터가 만날 때까지** 반복한다.

![image-20241231152907201](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231152907201.png)

![image-20241231153006223](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153006223.png)![image-20241231153026269](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153026269.png)

![image-20241231153051578](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153051578.png)![image-20241231153456808](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153456808.png)

![image-20241231153529597](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153529597.png)

![image-20241231153725529](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153725529-1735627046415-1.png)

![image-20241231153740730](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231153740730.png)

두 포인터가 엇갈렸음. 투 포인터 종료

![image-20241231164402332](../../../../Documents/GitHub/dalcheonroadhead-github-blog/dalcheonroadhead.github.io/images/018_퀵_정렬/image-20241231164402332.png)

pivot보다 작거나 같은 값 그룹, pivot보다 큰 값 그룹에 대하여 다시 처음부터 진행 

### Pivot이 다음 정렬 그룹 안에 포함되어도 괜찮나요? 🤔

네, 짜피 분할된 그룹 내에 포함되어도 정렬 이루어짐.

# 4. 코드

```java
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main {

    static int [] arr = new int [] {1,7,5,4,6,9,8,10,2,3};
    static int [] tmp = new int [10];
    public static void main(String[] args) throws IOException {
        quick_sort(0, 9, 0);

        System.out.println(Arrays.toString(arr));
    }

    public static void quick_sort (int start, int end, int depth) {
        // 0. 기저 조건
        if(start >= end) return;
        // 1. 정복 by 투 포인터
        int pivot_index = start + (end - start)/2;
        int pivot = arr[pivot_index];


        int L = start;
        int R = end;

        while (L <= R){
            while (arr[L] < pivot){
                L++;
            }
            while (arr[R] > pivot){
                R--;
            }
            
            if(L <= R){ // == 처리 안하면 영원히 두 포인터가 엇갈리지 않는 경우의 수가 생김
                int tmp = arr[L];
                arr[L] = arr[R];
                arr[R] = tmp;
                L++;    R--;
            }
        }

        System.out.println("depth-" + depth  + ": " + Arrays.toString(arr) + " / [[ pivot: " + pivot + " start: "+ start + " end: " + end + "]]");

        // 2. 분할 by 재귀
        quick_sort(start, R, depth+1);
        quick_sort(L, end, depth+1);
    }
}
```